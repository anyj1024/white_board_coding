# 快速排序 vs 归并排序 vs 堆排序

## 快速排序 (Quick Sort)

### 基本原理
- 选择一个"枢轴"(pivot)元素
- 将数组分区，使得小于枢轴的元素在左边，大于枢轴的在右边
- 递归地对左右两个子数组进行排序

### 特点
- 平均时间复杂度: O(n log n)
- 最坏时间复杂度: O(n²)
- 空间复杂度: O(log n)
- 不稳定排序

### 优点
- 通常比其他 O(n log n) 算法更快
- 原地排序，只需要很小的辅助栈

### 缺点
- 最坏情况下性能退化为 O(n²)
- 对于小数组，开销可能较大

## 归并排序 (Merge Sort)

### 基本原理
- 将数组分成两半
- 递归地对两半进行排序
- 合并两个已排序的子数组

### 特点
- 时间复杂度: O(n log n)（各种情况下都是）
- 空间复杂度: O(n)
- 稳定排序

### 优点
- 稳定的 O(n log n) 性能
- 适合外部排序

### 缺点
- 需要额外的 O(n) 空间
- 对于小数组，可能不如插入排序等简单算法

## 堆排序 (Heap Sort)

### 基本原理
- 首先建立一个大根堆（或小根堆）
- 然后将堆顶元素与数组最后一个元素交换
- 重新调整剩余 n-1 个元素使之成为大根堆
- 重复上述过程直到数组有序

### 特点
- 平均时间复杂度: O(n log n)
- 最坏时间复杂度: O(n log n)
- 空间复杂度: O(1)
- 不稳定排序

### 优点
- 不需要额外空间，原地排序
- 在处理大规模数据时表现优秀

### 缺点
- 不是稳定排序算法
- 对于小数组，可能不如其他算法高效

## 比较

| 特性 | 快速排序 | 归并排序 | 堆排序 |
|------|----------|----------|--------|
| 平均时间复杂度 | O(n log n) | O(n log n) | O(n log n) |
| 最坏时间复杂度 | O(n²) | O(n log n) | O(n log n) |
| 空间复杂度 | O(log n) | O(n) | O(1) |
| 稳定性 | 不稳定 | 稳定 | 不稳定 |
| 原地排序 | 是 | 否 | 是 |

## 适用场景
- 快速排序：
  - 当平均性能很重要时
  - 内存空间有限时
- 归并排序：
  - 需要稳定排序时
  - 外部排序
  - 对链表进行排序
- 堆排序：
  - 处理大规模数据时
  - 内存受限但不需要稳定性

## 结论
选择使用哪种排序算法取决于具体的应用场景、数据特征和系统限制。快速排序通常在实践中更快,但归并排序提供了稳定性和最坏情况下的性能保证。堆排序则是在处理大规模数据时一个很好的选择,因为它不需要额外空间,且仍保持较高的效率。开发者需要根据实际需求权衡各算法的优缺点,选择最适合的方案。