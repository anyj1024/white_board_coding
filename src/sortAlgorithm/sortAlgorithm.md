# 快速排序 vs 归并排序

## 快速排序 (Quick Sort)

### 基本原理
- 选择一个"枢轴"(pivot)元素
- 将数组分区，使得小于枢轴的元素在左边，大于枢轴的在右边
- 递归地对左右两个子数组进行排序

### 特点
- 平均时间复杂度: O(n log n)
- 最坏时间复杂度: O(n²)
- 空间复杂度: O(log n)
- 不稳定排序

### 优点
- 通常比其他 O(n log n) 算法更快
- 原地排序，只需要很小的辅助栈

### 缺点
- 最坏情况下性能退化为 O(n²)
- 对于小数组，开销可能较大

## 归并排序 (Merge Sort)

### 基本原理
- 将数组分成两半
- 递归地对两半进行排序
- 合并两个已排序的子数组

### 特点
- 时间复杂度: O(n log n)（各种情况下都是）
- 空间复杂度: O(n)
- 稳定排序

### 优点
- 稳定的 O(n log n) 性能
- 适合外部排序

### 缺点
- 需要额外的 O(n) 空间
- 对于小数组，可能不如插入排序等简单算法

## 比较

| 特性 | 快速排序 | 归并排序 |
|------|----------|----------|
| 平均时间复杂度 | O(n log n) | O(n log n) |
| 最坏时间复杂度 | O(n²) | O(n log n) |
| 空间复杂度 | O(log n) | O(n) |
| 稳定性 | 不稳定 | 稳定 |
| 原地排序 | 是 | 否 |

## 适用场景
- 快速排序：
    - 当平均性能很重要时
    - 内存空间有限时
- 归并排序：
    - 需要稳定排序时
    - 外部排序
    - 对链表进行排序

## 结论
选择使用快速排序还是归并排序取决于具体的应用场景、数据特征和系统限制。快速排序通常在实践中更快，但归并排序提供了稳定性和最坏情况下的性能保证。